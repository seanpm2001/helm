# Default values for the langsmith helm chart. Refer to documentation on individual values for help with configuration.

# -- Provide a name in place of `langsmith`
nameOverride: ""
# -- String to fully override `"langsmith.fullname"`
fullnameOverride: ""
# -- Annotations that will be applied to all resources created by the chart
commonAnnotations: {}
# -- Labels that will be applied to all resources created by the chart
commonLabels: {}

global:
  azure:
    webhookUri: "https://langsmith-billing-admin.azurewebsites.net/api/container?sig=MTA3ZGY1ODEtMmY4OC00MjRhLWJjNzctNzZiMGExYWZmNzY3"
    productID: "langsmith"
    identity:
      # Application's Managed Service Identity (MSI) Client ID. ClientID can be used to generate authentication token to communicate to external services like Microsoft Marketplace Metering API
      clientId: "DONOTMODIFY" # Azure populates this value at deployment time
    marketplace:
      # id of the plan purchased for the Azure Marketplace Kubernetes application,to be used in usage event payload to metering api, for more information please refer: https://learn.microsoft.com/en-us/partner-center/marketplace/marketplace-metering-service-apis
      planId: "DONOTMODIFY" # Azure populates this value at deployment time
    extension:
      # resource id of the Azure Marketplace Kubernetes application,to be used in usage event payload to metering api, for more information please refer: https://learn.microsoft.com/en-us/partner-center/marketplace/marketplace-metering-service-apis
      resourceId: "DONOTMODIFY" # application's Azure Resource ID, Azure populates this value at deployment time
    images:
      backendImage:
        tag: "0.3.5"
        image: "langsmith-backend"
        registry: "langsmith.azurecr.io"
        pullPolicy: IfNotPresent
      frontendImage:
        tag: "0.3.5"
        image: "langsmith-frontend"
        registry: "langsmith.azurecr.io"
        pullPolicy: IfNotPresent
      platformBackendImage:
        tag: "0.3.5"
        image: "langsmith-go-backend"
        registry: "langsmith.azurecr.io"
        pullPolicy: IfNotPresent
      playgroundImage:
        tag: "0.3.5"
        image: "langsmith-playground"
        registry: "langsmith.azurecr.io"
        pullPolicy: IfNotPresent
      postgresImage:
        tag: "14.7"
        image: "postgres"
        registry: "langsmith.azurecr.io"
        pullPolicy: IfNotPresent
      redisImage:
        tag: "7"
        image: "redis"
        registry: "langsmith.azurecr.io"
        pullPolicy: IfNotPresent
      clickhouseImage:
        tag: "23.9"
        image: "clickhouse-server"
        registry: "langsmith.azurecr.io"
        pullPolicy: IfNotPresent
      customMetersAcceleratorImage:
        tag: "92049a3"
        image: "custom-meters-accelerator"
        registry: "langsmith.azurecr.io"
        pullPolicy: IfNotPresent

ingress:
  enabled: false
  hostname: ""
  subdomain: ""
  ingressClassName: ""
  annotations: {}
  labels: {}
  tls: []

apiIngress:
  enabled: false
  hostname: ""
  subdomain: ""
  ingressClassName: ""
  annotations: {}
  labels: {}
  tls: []

config:
  existingSecretName: ""
  openaiApiKey: ""
  langsmithLicenseKey: ""
  apiKeySalt: ""
  logLevel: "info"
  oauth:
    enabled: false
    oauthClientId: ""
    oauthIssuerUrl: ""

backend:
  name: "backend"
  containerPort: 1984
  deployment:
    replicas: 1
    labels: {}
    annotations: {}
    podSecurityContext: {}
    securityContext: {}
    command:
      - "uvicorn"
      - "app.main:app"
      - "--host"
      - "0.0.0.0"
      - "--port"
      - "$(PORT)"
      - "--log-level"
      - "$(LOG_LEVEL)"
      - "--loop"
      - "uvloop"
      - "--http"
      - "httptools"
      - "--no-access-log"
    resources:
      requests:
        cpu: 500m
        memory: 1Gi
    extraContainerConfig: {}
    extraEnv: []
    sidecars: []
    nodeSelector: {}
    tolerations: []
    affinity: {}
    volumes: []
    volumeMounts: []
  migrations:
    enabled: true
    labels: {}
    annotations: {}
    podSecurityContext: {}
    securityContext: {}
    resources: {}
#      limits:
#        cpu: 1000m
#        memory: 1Gi
#      requests:
#        cpu: 200m
#        memory: 500Mi
    command:
      - "/bin/bash"
      - "-c"
      - "alembic upgrade head"
    extraContainerConfig: {}
    extraEnv: []
    sidecars: []
    nodeSelector: {}
    tolerations: []
    affinity: {}
    volumes: []
    volumeMounts: []
  clickhouseMigrations:
    enabled: true
    labels: {}
    annotations: {}
    podSecurityContext: {}
    securityContext: {}
    resources: {}
#      limits:
#        cpu: 1000m
#        memory: 1Gi
#      requests:
#        cpu: 200m
#        memory: 500Mi
    command:
      - "/bin/bash"
      - "-c"
      - "sleep 20s; migrate -source file://clickhouse/migrations -database 'clickhouse://$(CLICKHOUSE_HOST):$(CLICKHOUSE_NATIVE_PORT)?username=$(CLICKHOUSE_USER)&password=$(CLICKHOUSE_PASSWORD)&database=$(CLICKHOUSE_DB)&x-multi-statement=true&x-migrations-table-engine=MergeTree' up"
    extraContainerConfig: {}
    extraEnv: []
    sidecars: []
    nodeSelector: {}
    tolerations: []
    affinity: {}
    volumes: []
    volumeMounts: []
  autoscaling:
    enabled: true
    # If enabled, use the following values to configure the HPA. You can also use your own HPA configuration by not creating an HPA.
    # You may want to manage the HPA yourself if you have a custom autoscaling setup like KEDA.
    createHpa: true
    minReplicas: 1
    maxReplicas: 10
    targetCPUUtilizationPercentage: 80
    targetMemoryUtilizationPercentage: 80
  service:
    type: ClusterIP
    port: 1984
    labels: {}
    annotations: {}
    loadBalancerSourceRanges: []
    loadBalancerIP: ""
  serviceAccount:
    create: true
    name: ""
    labels: {}
    annotations: {}

clickhouse:
  name: "clickhouse"
  external:
    # If enabled, use the following values to connect to an external database. This will also disable the
    # creation of a clickhouse stateful-set and service.
    enabled: false
    host: ""
    port: "8123"
    nativePort: "9000"
    user: "default"
    password: "password"
    database: "default"
    tls: false
    existingSecretName: ""
  containerHttpPort: 8123
  containerNativePort: 9000
  statefulSet:
    labels: {}
    annotations: {}
    podSecurityContext: {}
    securityContext: {}
    resources:
      requests:
        cpu: 1500m
        memory: 3500Mi
    command:
      - "/bin/bash"
      - "-c"
      - "sed 's/id -g/id -gn/' /entrypoint.sh > /tmp/entrypoint.sh; exec bash /tmp/entrypoint.sh"
    extraContainerConfig: {}
    extraEnv: []
    sidecars: []
    nodeSelector: {}
    tolerations: []
    affinity: {}
    volumes: []
    volumeMounts: []
    # We recommend using a persistent volume and increasing the storage size to something like 50Gi when using in a production environment!
    persistence:
      size: 8Gi
      storageClassName: ""
  service:
    type: ClusterIP
    httpPort: 8123
    nativePort: 9000
    labels: {}
    annotations: {}
    loadBalancerSourceRanges: []
    loadBalancerIP: ""
  serviceAccount:
    create: true
    name: ""
    labels: {}
    annotations: {}

frontend:
  name: "frontend"
  containerPort: 8080
  existingConfigMapName: ""
  deployment:
    replicas: 1
    labels: {}
    annotations: {}
    podSecurityContext: {}
    securityContext: {}
    command:
      - "/entrypoint.sh"
    resources:
      requests:
        cpu: 200m
        memory: 500Mi
    extraContainerConfig: {}
    extraEnv: []
    sidecars: []
    nodeSelector: {}
    tolerations: []
    affinity: {}
    volumes: []
    volumeMounts: []
  autoscaling:
    enabled: true
    # If enabled, use the following values to configure the HPA. You can also use your own HPA configuration by not creating an HPA.
    # You may want to manage the HPA yourself if you have a custom autoscaling setup like KEDA.
    createHpa: true
    minReplicas: 1
    maxReplicas: 10
    targetCPUUtilizationPercentage: 80
  service:
    type: ClusterIP
    httpPort: 80
    httpsPort: 443
    labels: {}
    annotations: {}
    loadBalancerSourceRanges: []
    loadBalancerIP: ""
  serviceAccount:
    create: true
    name: ""
    labels: {}
    annotations: {}

playground:
  name: "playground"
  containerPort: 3001
  deployment:
    replicas: 1
    labels: {}
    annotations: {}
    podSecurityContext: {}
    securityContext: {}
    command:
      - "node"
      - "./scripts/run-playground-docker.mjs"
    resources:
      requests:
        cpu: 200m
        memory: 500Mi
    extraContainerConfig: {}
    extraEnv: []
    sidecars: []
    nodeSelector: {}
    tolerations: []
    affinity: {}
    volumes: []
    volumeMounts: []
  autoscaling:
    enabled: true
    createHpa: true
    minReplicas: 1
    maxReplicas: 10
    targetCPUUtilizationPercentage: 80
    targetMemoryUtilizationPercentage: 80
  service:
    type: ClusterIP
    port: 3001
    labels: {}
    annotations: {}
    loadBalancerSourceRanges: []
    loadBalancerIP: ""
  serviceAccount:
    create: true
    name: ""
    labels: {}
    annotations: {}

postgres:
  name: "postgres"
  external:
    # If enabled, use the following values to connect to an external database. This will also disable the
    # creation of a postgres stateful-set and service.
    enabled: false
    host: ""
    port: "5432"
    user: "postgres"
    password: "postgres"
    database: "postgres"
    schema: "public"
    # If connection string is specified, we will ignore all above values and use the connection string instead.
    # Do not include the driver name(something like "postgres://" in the connection string.
    connectionUrl: ""
    existingSecretName: ""
  containerPort: 5432
  statefulSet:
    labels: {}
    annotations: {}
    podSecurityContext: {}
    securityContext: {}
    resources:
      requests:
        cpu: 1000m
        memory: 2Gi
    command: []
    extraContainerConfig: {}
    extraEnv: []
    sidecars: []
    nodeSelector: {}
    tolerations: []
    affinity: {}
    volumes: []
    volumeMounts: []
    persistence:
      size: 8Gi
      storageClassName: ""
  service:
    type: ClusterIP
    port: 5432
    labels: {}
    annotations: {}
    loadBalancerSourceRanges: []
    loadBalancerIP: ""
  serviceAccount:
    create: true
    name: ""
    labels: {}
    annotations: {}

queue:
  name: "queue"
  deployment:
    replicas: 3
    labels: {}
    annotations: {}
    podSecurityContext: {}
    securityContext: {}
    resources:
      requests:
        cpu: 1000m
        memory: 2000Mi
    command:
      - "saq"
      - "app.workers.queues.single_queue_worker.settings"
      - "--quiet"
    extraContainerConfig: {}
    extraEnv: []
    sidecars: []
    nodeSelector: {}
    tolerations: []
    affinity: {}
    volumes: []
    volumeMounts: []
  autoscaling:
    enabled: true
    # If enabled, use the following values to configure the HPA. You can also use your own HPA configuration by not creating an HPA.
    # You may want to manage the HPA yourself if you have a custom autoscaling setup like KEDA.
    createHpa: true
    minReplicas: 3
    maxReplicas: 10
    targetCPUUtilizationPercentage: 80
    targetMemoryUtilizationPercentage: 80
  serviceAccount:
    create: true
    name: ""
    labels: {}
    annotations: {}

platformBackend:
  name: "platform-backend"
  containerPort: 1986
  existingConfigMapName: ""
  deployment:
    replicas: 1
    labels: {}
    annotations: {}
    podSecurityContext: {}
    securityContext: {}
    resources: {}
#      limits:
#        cpu: 1000m
#        memory: 1Gi
#      requests:
#        cpu: 200m
#        memory: 500Mi
    command:
      - "./smith-go"
    extraContainerConfig: {}
    extraEnv: []
    sidecars: []
    nodeSelector: {}
    tolerations: []
    affinity: {}
    volumes: []
    volumeMounts: []
  autoscaling:
    enabled: false
    # If enabled, use the following values to configure the HPA. You can also use your own HPA configuration by not creating an HPA.
    # You may want to manage the HPA yourself if you have a custom autoscaling setup like KEDA.
    createHpa: true
    minReplicas: 1
    maxReplicas: 5
    targetCPUUtilizationPercentage: 80
  service:
    type: ClusterIP
    port: 1986
    labels: {}
    annotations: {}
    loadBalancerSourceRanges: []
    loadBalancerIP: ""
  serviceAccount:
    create: true
    name: ""
    labels: {}
    annotations: {}

redis:
  name: "redis"
  external:
    # If enabled, use the following values to connect to an external redis instance. This will also disable the
    # creation of a redis stateful-set and service.
    enabled: false
    connectionUrl: ""
    existingSecretName: ""
  containerPort: 6379
  statefulSet:
    labels: {}
    annotations: {}
    podSecurityContext: {}
    securityContext: {}
    resources:
      requests:
        cpu: 1000m
        memory: 2Gi
    command: []
    extraContainerConfig: {}
    extraEnv: []
    sidecars: []
    nodeSelector: {}
    tolerations: []
    affinity: {}
    volumes: []
    volumeMounts: []
    persistence:
      enabled: true
      size: 8Gi
      storageClassName: ""
  service:
    type: ClusterIP
    port: 6379
    labels: {}
    annotations: {}
    loadBalancerSourceRanges: []
    loadBalancerIP: ""
  serviceAccount:
    create: true
    name: ""
    labels: {}
    annotations: {}
